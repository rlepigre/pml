\chapter{Existential, singleton and dependent type}

\section{Vector}

The canonical example of dependent type is the type of vector,
that is list of a given size.

PML offers two ways to define vectors.

\begin{pmlcode}
  include lib.nat
  include lib.list

  type vec⟨a,n⟩ = { l ∈ list⟨a⟩ | length l ≡ n }

  val vec_to_list : ∀a, ∀n, vec⟨a,n⟩ ⇒ list⟨a⟩ = fun v { v }

  val list_to_vec : ∀a, ∀l∈list⟨a⟩, vec⟨a, length l⟩ = fun v { v }
\end{pmlcode}

This exemple is using \emph{comprehension} to form type. In fact, this
is not a primitive type, it is defined using:
\begin{itemize}
\item existential type: \dupml{∃x:s, t⟨x⟩} which is the union of all
  type \dupml{t⟨x⟩} for all \dupml{x} of sort \dupml{s}. In general PML
  can infer the sort of \dupml{x} and we can simly write \dupml{∃x, t⟨x⟩}.
  It is often necessary to indicate the sort for \dupml{ι} and \dupml{τ}, because of subtyping.

\item singleton type: \dupml{u ∈ t} which is the type only inhabited by
  \dupml{u} of type \dupml{t}

\item restriction: \dupml{t | u ≡ v} which is the same type as \dupml{t} if
  the two terms \dupml{u} and \dupml{v} are equivalent. Otherwise, this is the
  empty type.
\end{itemize}

Using this, the type \dupml{{ l ∈ list⟨a⟩ | length l ≡ n }} is a syntactic
sugar for \dupml{∃l, l ∈ list⟨a⟩ | length l ≡ n} which reads as
``the union of all singletons \dupml{l ∈ list⟨a⟩} such that \dupml{length l ≡ n}''.


\section{Set and search trees}

Here is a definition of binary trees:

\begin{pmlcode}
  type rec bt⟨a⟩ = [ Nil
                   ; Node of { l : bt⟨a⟩ ; e : a ; r : bt⟨a⟩ ; ⋯ } ]
\end{pmlcode}

Notice the dots in the record type. It means that more fields are allowed.
By default in PML record are strict and shouldhave exactly the label
mentionned in the type, but record with more fields are also possible.

We want binary search trees.
This means
that elements stored in \dupml{l} (resp. \dupml{r}) should be smaller
(resp. bigger) than \dupml{e}. But this is not written in the type.
To overcome this, we can define a function and use a few more advanced
feature of PML!

\begin{pmlcode}
include lib.bool
include lib.comparison

val rec for_all : ∀a, (a ⇒ bool) ⇒ bt⟨a⟩ ⇒ bool = fun f t {
  case t {
    | []              → true
    | Node[{l, e, r}] → f e && for_all f l && for_all f r
  }
}

type rec st⟨a,c⟩ = [ Nil; Node of
  ∃e, { l : { t ∈ st⟨a,c⟩ | for_all (λx.is_Ls (c x e)) t }
      ; e : e ∈ a
      ; r : { t ∈ st⟨a,c⟩ | for_all (λx.is_Gr (c x e)) t }
      ; ⋯ } ]

// We can check that search trees are binary trees.
assert ∀a,∀c, st⟨a,c⟩ ⊂ bt⟨a⟩
\end{pmlcode}

First, the function \dupml{for_all f t} checks that the function \dupml{f}
return \dupml{true} for all the elements stored in the tree \dupml{t}.

Second, we define the type \dupml{st⟨a,c⟩} which is parameterised by a type
\dupml{a} and a comparison function that is suppose to rerun value of the type
\dupml{[ Ls; Eq; Gr]}. The module \dupml{lib.comparison} define the functions
\dupml{is_Ls} and \dupml{is_Gr} to check the return
value of the function \dupml{c}.

Using this, comprehension and the function \dupml{for_all}, we can check that
the ordering is respected.

Remark: to talk about one field (here \dupml{e})
of the record signature in the type of the other fields, we use
existential and membership to make sure \dupml{e} is available
everywhere.

Now, we can define the function doing insertion in a binary search tree:
\begin{pmlcode}
val rec insert : ∀a, (a ⇒ a ⇒ cmp) ⇒ a ⇒ bt⟨a⟩ ⇒ bt⟨a⟩ =
  fun c e t {
    case t {
      | []                → Node[l = [], e, r = []]
      | Node[ l, e=e', r] →
        case c e e' {
          | Eq → t
          | Ls → Node[l = insert c e l, e = e', r]
          | Gr → Node[l, e = e', r = insert c e r]
        }
    }}
\end{pmlcode}

Unfortunately, this function does not have the type that would express
that it works on binary search tree. But we can fix that,
first using a lemma, and then a second function \dupml{insert2}
with the intended type.

\begin{pmlcode}
val rec lem : ∀a, ∀c∈(a ⇒ a ⇒ cmp), ∀f∈(a ⇒ bool),∀t∈bt⟨a⟩,∀e∈a,
          for_all f t ⇒ f e ⇒ for_all f (insert c e t) =
  fun c f t e ht he { set auto 1 1;
    case t {
      | []                  → {}
      | Node[ l, e=e', r] →
        deduce f e';
        deduce for_all f r;
        deduce for_all f l;
        case c e e' {
          | Eq → {}
          | Ls →
            let hl : for_all f (insert c e l) = lem c f l e {} he;
            {}
          | Gr →
            let hr : for_all f (insert c e r) = lem c f r e {} he;
            {}
        }
  }}

val rec insert2 : ∀a, ∀c∈(a ⇒ a ⇒ cmp), ∀e∈a, ∀t∈st⟨a,c⟩,
                 insert c e t ∈ st⟨a,c⟩ =
  fun c e t {
    case t {
      []                 → Node[ l = [], e, r = []]
      Node[l, e=e', r] →
        let ls = λx.is_Ls (c x e');
        let gr = λx.is_Gr (c x e');
        deduce for_all ls l;
        deduce for_all gr r;
        case c e e' {
          Eq → t
          Ls → let l'  = insert2 c e l;
               deduce for_all ls l' by lem c ls l e {} {};
               Node[l=l', e=e', r]
          Gr → let r' = insert2 c e r;
               deduce for_all gr r' by lem c gr r e {} {};
               Node[l, e=e', r=r']
        }
    }}
\end{pmlcode}

Finally, because the above function is more complex that the previous one, we
can use the \dupml{check ⋯ for ⋯} construct of PML to give the intended to the
original function \dupml{insert}.

This contruction \dupml{check t for u}, allows for type-checking \dupml{t} in
place of \dupml{u}, providing that \dupml{t ≡ u} holds. Here the type of
\dupml{insert2 c e t} is \dupml{insert c e t ∈ st⟨a,c⟩} which enforces the
wanted equality.

This construction will also allow for manually proving termination of
function...

\begin{pmlcode}
val insert : ∀o,∀a,∀c∈(a ⇒ a ⇒ cmp), a ⇒ st⟨a,c⟩ ⇒ st⟨a,c⟩ =
  fun c e t { check insert2 c e t for insert c e t }
\end{pmlcode}

We can now define the search function:
\begin{pmlcode}
val rec mem : ∀a,∀c∈(a ⇒ a ⇒ cmp), a ⇒ st⟨a,c⟩ ⇒ bool =
  fun c e t {
    case t {
      [] → false
      Node[l, e=e', r] → case c e e' {
        Ls → mem c e l
        Eq → true
        Gr → mem c e r
      }
    }
  }

// TODO: auto is not working well and this example.
// probably normalisation in the pool, with the c.f in head position?
val rec mem_correct : ∀a,∀c∈preorder⟨a⟩,∀e e'∈a,∀t∈st⟨a,c.f⟩,
                        mem c.f e (insert c.f e' t) ≡ (is_Eq (c.f e e') || mem c.f e t) =
  fun c e e' t {
    set auto 1 2;
    case t {
      []                → qed
      Node[l, e=e'', r] →
        case c.f e e'' {
        Ls → deduce mem c.f e (insert c.f e' l) ≡ is_Eq (c.f e e') || mem c.f e l
             by mem_correct c e e' l;
             case c.f e' e'' {
               Ls → qed
               Eq → deduce c.f e'' e' ≡ Eq by c.sym e' e'';
                    deduce c.f e e' ≡ Ls by c.trans e e' e'';
                    qed
               Gr → deduce c.f e'' e' ≡ Ls by c.sym e' e'';
                    deduce c.f e e' ≡ Ls by c.trans e e' e'';
                    qed
             }
        Eq → qed
        Gr → deduce mem c.f e (insert c.f e' r) ≡ is_Eq (c.f e e') || mem c.f e r
             by mem_correct c e e' r;
             case c.f e' e'' {
               Gr → qed
               Eq → deduce c.f e'' e' ≡ Eq by c.sym e' e'';
                    deduce c.f e e' ≡ Gr by c.trans e e' e'';
                    qed
               Ls → deduce c.f e'' e' ≡ Gr by c.sym e' e'';
                    deduce c.f e e' ≡ Gr by c.trans e e' e'';
                    qed
             }
      }
    }
  }

\end{pmlcode}


%<!-- Local IspellDict: british -->
%<!-- Local IspellPersDict: ~/.ispell-british -->
