\chapter{Existential, singleton and dependent type}

\section{Vector}

The canonical example of dependent type is the type of vector,
that is list of a given size.

PML offers two ways to define vectors.

\begin{pmlcode}
  include lib.nat
  include lib.list

  type vec⟨a,n⟩ = { l ∈ list⟨a⟩ | length l ≡ n }

  val vec_to_list : ∀a, ∀n, vec⟨a,n⟩ ⇒ list⟨a⟩ = fun v { v }

  val list_to_vec : ∀a, ∀l∈list⟨a⟩, vec⟨a, length l⟩ = fun v { v }
\end{pmlcode}

This exemple is using \emph{comprehension} to form type. In fact, this
is not a primitive type, it is defined using:
\begin{itemize}
\item existential type: \dupml{∃x:s, t⟨x⟩} which is the union of all
  type \dupml{t⟨x⟩} for all \dupml{x} of sort \dupml{s}. In general PML
  can infer the sort of \dupml{x} and we can simly write \dupml{∃x, t⟨x⟩}.
  It is often necessary to indicate the sort for \dupml{ι} and \dupml{τ}, because of subtyping.

\item singleton type: \dupml{u ∈ t} which is the type only inhabited by
  \dupml{u} of type \dupml{t}

\item restriction: \dupml{t | u ≡ v} which is the same type as \dupml{t} if
  the two terms \dupml{u} and \dupml{v} are equivalent. Otherwise, this is the
  empty type.
\end{itemize}

Using this, the type \dupml{{ l ∈ list⟨a⟩ | length l ≡ n }} is a syntactic
sugar for \dupml{∃l, l ∈ list⟨a⟩ | length l ≡ n} which reads as
``the union of all singletons \dupml{l ∈ list⟨a⟩} such that \dupml{length l ≡ n}''.


\section{Set and search trees}

\begin{pmlcode}
  type rec st1⟨a⟩ = [ Nil
                   ; Node of { l : st1⟨a⟩ ; e : a ; r : st1⟨a⟩ ; ⋯ } ]
\end{pmlcode}

Notice the dots in the record type. It means that more fields are allowed.
By default in PML record are strict and shouldhave exactly the label
mentionned in the type, but record with more fields are also possible.

Before using this feature, there is another issue. This type is intended to represent binary search trees which means
that elements stored in \dupml{l} (resp. \dupml{r}) should be smaller
(resp. bigger) than \dupml{e}. But this is not written in the type.
To overcome this, we can define a function and use a few more advanced
feature of PML!

\begin{pmlcode}
  include lib.bool
  include lib.comparison

  val rec for_all : ∀a, (a ⇒ bool) ⇒ st1⟨a⟩ ⇒ bool = fun f t {
    case t {
      | []               → true
      | Node[{ l; e; r}] → f e && for_all f l && for_all f r
    }
  }

  type rec st⟨a,cmp⟩ = [ Nil
    ; Node of
    ∃e, { l : { t ∈ st⟨a,cmp⟩ | for_all (λx.is_Ls (cmp x e)) t }
        ; e : e ∈ a
        ; r : { t ∈ st⟨a,cmp⟩ | for_all (λx.is_Gs (cmp x e)) t }
      ; ⋯ } ]

  val rec add : ∀a, a ⇒ st1⟨a⟩ ⇒ st1⟨a⟩ = {--}
\end{pmlcode}

%<!-- Local IspellDict: british -->
%<!-- Local IspellPersDict: ~/.ispell-british -->
