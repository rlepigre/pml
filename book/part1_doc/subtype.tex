\chapter{Subtyping, polymorphic variants}

\section{Append lists}

As first example using subtyping, we will consider the type of lists
extended with a append constructor, this type is a kind of mixture of
lists and binary trees. More importantly, any list will be an append list.

\begin{pmlcode}
  include lib.nat
  include lib.list

  type rec alist⟨a⟩ = [Nil
                      ; Cons of {hd : a ; tl : alist⟨a⟩}
                      ; Append of {l : alist⟨a⟩; r : alist⟨a⟩}]

  assert ∀a, list⟨a⟩ ⊂ alist⟨a⟩
  assert ¬ ∀a, alist⟨a⟩ ⊂ list⟨a⟩
\end{pmlcode}

We see that the type \dupml{alist} is identical to \dupml{list} except
for an extra constructor \dupml{Append}. This implies that a \dupml{list}
is also an \dupml{alist} while the converse is false. We say that the type
\dupml{list} is a \emph{subtype} of \dupml{alist}. The converse is naturally
false and this can be checked using the \dupml{assert} keyword.

Here is a function converting an append list to a list.

\begin{pmlcode}
  val rec alist_to_list : ∀a, alist⟨a⟩ ⇒ list⟨a⟩ =
  fun l {
    case l {
      []             → []
      h::l           → h::alist_to_list l
      Append[{l; r}] → alist_to_list l @ alist_to_list r
    }
  }
\end{pmlcode}

\begin{exercise}\label{exo-alist-1}
  Define a \dupml{alist_map} function for \dupml{alist} and show that
  mapping and converting to list or converting to list and then mapping yield
  the same result.
\end{exercise}

\section{Integer}

The fact we can use the same variants constructors for two distinct types is
named \emph{polymorphic} variants. Another example of such polymorphic
variant is for unary integers.

\begin{pmlcode}
  // Normalized integers
  type rec pos = [Zero; S of pos]
  type rec neg = [Zero; P of neg]
  type int = [Zero; S of pos; P of neg]

  // Non normalised
  type rec nint = [Zero; S of nint; P of nint]

  assert nat ⊂ int
  assert int ⊂ nint

  val zero : int = Zero // For 0 to work
\end{pmlcode}

The way we define the type \dupml{int} forbids integer like
\dupml{S[P[Zero]]} yielding a unique representation of each integer (its
normal represetation). We also provide a type allowing non normal
representation and we check the expected subtyping relation using \dupml{assert}.

Then, we can write the successor and predecessor functions:

\begin{pmlcode}
  val suc : int ⇒ int = fun n {
    case n {
      0    → S[0]
      S[p] → S[S[p]]
      P[s] → s
    }
  }

  val pre : int ⇒ int = fun n {
    case n {
      0    → P[0]
      P[s] → P[P[s]]
      S[p] → p
    }
  }
\end{pmlcode}

This code is not optimal because for the second case of \dupml{suc}, we need
to write \dupml{S[p] → S[S[p]]} while \dupml{S[_] → S[n]} would be preferable
  but \dupml{n} is of type \dupml{int} and not of type \dupml{pos}.  However
  \dupml{check ... for ...} offers a solution as we know that \dupml{S[p] ≡
    n}.

\begin{pmlcode}
  val suc : int ⇒ int = fun n {
    case n {
      0    → S[0]
      S[p] → S[check S[p] for n]
      P[s] → s
    }
  }

  val pre : int ⇒ int = fun n {
    case n {
      0    → P[0]
      P[s] → P[check P[s] for n]
      S[p] → p
    }
  }
\end{pmlcode}

For the opposite, the following code is not accepted.
\begin{badpmlcode}
  val rec opp : int ⇒ int = fun n {
    case n {
      0    → 0
      S[p] → P[opp p]
      P[s] → S[opp s]
    }
  }
\end{badpmlcode}

Indeed, in the successor case, PML would need to know that
\dupml{opp p} is of type \dupml{neg} while it is only of type
\dupml{int}. Two solutions, first using \dupml{suc} and \dupml{pre}:
\begin{pmlcode}
  val rec opp : int ⇒ int = fun n {
    case n {
      0    → 0
      S[p] → pre (opp p)
      P[s] → suc (opp s)
    }
  }
\end{pmlcode}
or two auxiliary functions for the types \dupml{pos}
and \dupml{neg}

\begin{pmlcode}
  val rec opp_pos : pos ⇒ neg = fun n {
    case n {
      0    → 0
      S[p] → P[opp_pos p]
    }
  }

  val rec opp_neg : neg ⇒ pos = fun n {
    case n {
    0    → 0
    P[s] → S[opp_neg s]
    }
  }

  val rec opp : int ⇒ int = fun n {
    case n {
      0    → 0
      S[p] → P[opp_pos p]
      P[s] → S[opp_neg s]
    }
  }
\end{pmlcode}

From the functions above, we easily get addition
and subtraction:

\begin{pmlcode}
  infix (+) = add priority 3 left associative

  val rec (+) : int ⇒ int ⇒ int = fun n m {
    case n {
      0    → m
      S[n] → suc (n + m)
      P[n] → pre (n + m)
    }
  }

  infix (-) = minus priority 3 left associative

  val rec (-) : int ⇒ int ⇒ int = fun n m { n + opp m }
\end{pmlcode}

\begin{exercise}\label{exo-int-1}
  Define multiplication and prove the commutative ring axioms for
  \dupml{int}.
\end{exercise}

\begin{exercise}\label{exo-int-2}
  Use \dupml{check ⋯ for ⋯} to type-check the first version of \dupml{opp}
  above. You will need advanced feature like comprehension and restriction described later in this document.
\end{exercise}

\section{Extensible lists}

PML also supports a form of subtyping for records. Here is an exemple which
is a very small variation on lists.

\begin{pmlcode}
  type rec elist⟨a⟩ = [ Nil ; Cons of { hd : a; tl : elist⟨a⟩; ⋯} ]

  assert list⟨nat⟩ ⊂ elist⟨nat⟩
  assert ¬ elist⟨nat⟩ ⊂ list⟨nat⟩
\end{pmlcode}

The only difference are the dots at the end of the record type meaning
that more fields may be present. Adding no field, we can use this type to represent set.
We use \dupml{ens} as type name because \dupml{set} is a reserved keyword.
\begin{pmlcode}
  include lib.bool

  type ens⟨a⟩ = elist⟨a⟩

  val empty : ∀a, ens⟨a⟩ = []
  val add : ∀a, a ⇒ ens⟨a⟩ ⇒ ens⟨a⟩ = fun x s { x :: s }
  val rec mem : ∀a, (a ⇒ a ⇒ bool) ⇒ a ⇒ ens⟨a⟩ ⇒ bool = fun eq x s {
    case s {
      []    → false
      y::tl → eq x y || mem eq x tl
    }
  }
\end{pmlcode}

Note that we could have written the same code with \dupml{list}, except that
some subtyping below would fail. Because PML lacks a polymorphic equality
working at all types the function \dupml{mem} requires the equality as
argument. The relation \dupml{≡} can not be used as equality test, it
is used to form types only.

We can also use \dupml{elist} with one more field for association list.
Notice the subtyping that works.

\begin{pmlcode}
  type rec asslist⟨a,b⟩ = [ Nil ; Cons of { hd : a; tl : asslist⟨a,b⟩; v : b ;⋯} ]

  assert asslist⟨nat,bool⟩ ⊂ elist⟨nat⟩
  assert ¬ elist⟨nat⟩ ⊂ asslist⟨nat,bool⟩
  assert ¬ list⟨nat⟩ ⊂ asslist⟨nat,bool⟩
  assert ¬ asslist⟨nat,bool⟩ ⊂ list⟨nat⟩

  val add_assoc : ∀a b, a ⇒ b ⇒ asslist⟨a,b⟩ ⇒ asslist⟨a,b⟩ =
    fun hd v tl { Cons[{hd; v; tl}] }

  val mem_assoc : ∀a b, (a ⇒ a ⇒ bool) ⇒ a ⇒ asslist⟨a,b⟩ ⇒ bool = mem

  type option⟨a⟩ = [ None ; Some of a ]

  val rec find : ∀a b, (a ⇒ a ⇒ bool) ⇒ a ⇒ asslist⟨a,b⟩ ⇒ option⟨b⟩ =
    fun eq x a {
      case a {
        []      → None
        Cons[c] → if eq c.hd x { Some[c.v] } else { find eq x c.tl }
      }
    }
\end{pmlcode}

Thanks to subtyping, the function \dupml{mem} can also be used on association
list because the type of \dupml{mem} is a subtype of the type of
\dupml{memassoc}. This would fail if \dupml{set} were defined using
\dupml{list} instead of \dupml{elist}.

%<!-- Local IspellDict: british -->
%<!-- Local IspellPersDict: ~/.ispell-british -->
