\chapter{PML Basics}

\section{functions and algebraic data types}

\subsection{A simple enumerated type}\label{basics-day}

We start with a very simple example defining a data type for the days of the
week. This example is inspired by the software foundation course of Benjamin
  Pierce et all\cite{Pierce:SF1}:

\begin{pmlcode}
  type day = [ Monday ; Tuesday ; Wednesday
    ; Thursday ; Friday ; Saturday ; Sunday ]
\end{pmlcode}

This defines a data type \dupml{day} with seven constant elements
representing each day of the week. This kind of type is
called \emph{enumerated type}, \emph{variant type} or \emph{sum type}.
The seven elements are distinct constants and must start with an upper case
letter to distinguish them from variables.

We define functions using this type:

\begin{pmlcode}
  val next_day : day ⇒ day =
    fun d {
      case d {
        Monday    → Tuesday
        Tuesday   → Wednesday
        Wednesday → Thursday
        Thursday  → Friday
        Friday    → Saturday
        Saturday  → Sunday
        Sunday    → Monday
      }
    }

  val previous_day : day ⇒ day =
    fun d {
      case d {
        Monday    → Sunday
        Tuesday   → Monday
        Wednesday → Tuesday
        Thursday  → Wednesday
        Friday    → Thursday
        Saturday  → Friday
        Sunday    → Saturday
      }
    }

  val second_next_day : day ⇒ day =
    fun d { next_day (next_day d) }
\end{pmlcode}

The \dupml{val} keyword indicates that we define a PML value and is followed
by a name for this value and its type. Here \dupml{day ⇒ day} means a total
pure function that takes a \dupml{day} as argument and returns an element of
the same type.

The \dupml{fun} keyword denotes a function definition, followed by
a name for the argument of the function and the body of the function.
Finally, \dupml{case} denotes a case analysis on the value of the variable
\dupml{d}.

We can now prove two simple properties of these two functions:

\begin{pmlcode}
  val trivial : second_next_day Monday ≡ Wednesday = qed
\end{pmlcode}

For properties, we define values as for programs using the \dupml{val} keyword!
PML follows the Curry-Howard correspondence and identifies properties and types.
The type used for properties are richer, here it is an equality which is a
type inhabited if and only if the equality holds (we will see later what is
the element of this type). The body of the definition is just
\dupml{qed} meaning that the proof results only from a computation.
This first property is trivial for PML.

\begin{pmlcode}
  val next_previous_day : ∀d∈day, next_day (previous_day d) ≡ d =
    take d;
    case d {
      Monday    → qed
      Tuesday   → qed
      Wednesday → qed
      Thursday  → qed
      Friday    → qed
      Saturday  → qed
      Sunday    → qed
    }
\end{pmlcode}

Here, the type is more complex. It expresses that for any element \dupml{d}
of type \dupml{day}, applying the function \dupml{previous_day} to \dupml{d} and then applying
\dupml{next_day} to the result gives the initial value back.

The proof starts with the \dupml{take} keyword to introduce a fresh variable
\dupml{d} for an arbitrary day. In fact, we could use the \dupml{fun} keyword, both
are equivalent. Then, we perform a case analysis on \dupml{d} and in each case,
the proof results of a computation hence we can use \dupml{qed}. Indeed, if
\dupml{d ≡ Monday}, by definition \dupml{previous_day d ≡ Sunday}
and \dupml{next_day Sunday ≡ Monday ≡ d}. The same happens for all seven cases.

\begin{pmlcode}
  val previous_next_day : ∀d∈day, previous_day (next_day d) ≡ d =
    take d;
    set auto 1 0;
    qed
\end{pmlcode}

For the converse property, we give a shorter proof using the hability of PML
to perform some automatic theorem proving. In fact, it is very limited!
The directive \dupml{set auto 1 0} tells PML to perform at most one case
analysis (the 1) and no totality proof (the 0, we will see later what this
means). In fact, there is no magic: PML sees that the computation of
\dupml{next_day d} is blocked on a case analysis and try to proceed in the
proof using the same case analysis as the one in the program.

\begin{exercise}\label{exo-day-1}
  Prove that applying seven times the function \dupml{next_day} returns the initial
  day.
\end{exercise}

\subsection{Booleans}

The type of booleans is defined by

\begin{pmlcode}
  //type bool = [ true; false ]
\end{pmlcode}

Normally enumerated type should start with a capital letter. PML allows for an
exception with \dupml{true} and \dupml{false} as OCaml do. In fact booleans
are predefined and can not be redefined as they play a special role in a
few places in PML. This is why we give the definition as a comment.

Most definition in this section are in the standard library but we here redefine them
as they provide good examples.

We now define some standard function on booleans:

\begin{pmlcode}
  val not : bool ⇒ bool = fun b {
    case b { true → false | false → true }
  }

  val and : bool ⇒ bool ⇒ bool = fun b1 b2 {
    case b1 { true → b2 | false → false }
  }

  val or : bool ⇒ bool ⇒ bool = fun b1 b2 {
    if b1 { true } else { b2 }
  }
\end{pmlcode}

These examples are not different from the previous ones. The only novelty
are the function with two arguments. The type \dupml{bool ⇒ bool ⇒ bool}
should be read as \dupml{bool ⇒ (bool ⇒ bool)} (the function type is right
associative). This means that a function with two arguments is in fact
a function taking one argument returning a function.
The notation \dupml{fun b1 b2 { ⋯ }} is equivalent to \dupml{fun b1 { fun b2
    { ⋯ }}} making this more explicit.

The last definition show the \dupml{if ⋯ else ⋯} notation in PML which
is just a syntactic sugar for the case notation for booleans.

However, there is a problem with the definition of \dupml{and} and
\dupml{or}. Indeed, one usually expects that when evaluating a conjunction
(resp. a disjunction) of
two expressions, the second expression is only evaluated if the first
expression evaluates to \dupml{true} (resp. \dupml{false}).
As PML is in call by value, all arguments of a function are evaluated
before calling the function.

It is possible to fix this using the \dupml{def} keyword as follows

\begin{pmlcode}
  def land⟨a:τ,b:τ⟩ = if a { b } else { false }
  def lor ⟨a:τ,b:τ⟩ = if a { true } else { b }
\end{pmlcode}

In PML we define \emph{expressions} of various \emph{sorts}. For now we have seen
three sorts of expressions:
\begin{itemize}
\item propositions or types like \dupml{day}, \dupml{bool ⇒ bool}
  or \dupml{∀d∈day, previous_day (next_day d) ≡ d}. These are expressions of
  sort \dupml{ο} (omicron).
\item Values like \dupml{Monday}, \dupml{Tuesday} or \dupml{fun b { not b }}
  which are evaluated programs. These are expressiosn of sort \dupml{ι}
  (iota).
\item Terms or programs like \dupml{not b} or \dupml{if b { true } else {
    false }}. These are expressions of sort \dupml{τ} (tau). Moreover any
  value is also a term. We say that the sort \dupml{ι} is a \emph{subsort} of
  \dupml{τ}.
\end{itemize}

PML also support parametric expressions. Above,
\dupml{land} and \dupml{lor} are two expressions of sort \dupml{τ → τ →
  τ}. They can be seen as macros with two parameters. An important difference
between values defined with the \dupml{val} keyword and macros is that
\begin{itemize}
  \item Values are defined by giving a term and a type and PML performs
    type-checking to ensure that the term indeed belong to the given type.
    This ensures that the evaluation can not fail and will always returns
    a value of the given type.
  \item At the contrary, general expressions are not type-checked at their
    definition. PML checks that they have the intended sort, that is that
    \dupml{land} and \dupml{lor} returns terms when applied to two terms.
    But it does not check that these terms evaluates to boolean if given
    booleans. Macros are expended and type-checked only when used.
\end{itemize}

This means that \dupml{land⟨e1,e2⟩} is exactly the same
as \dupml{if e1 { e2 } else { false }}. This is what we want to
ensure that \dupml{e2} is only evaluated when \dupml{e1} evaluates to
\dupml{true}.

Then, we can give an infix syntax for conjunction and disjonction.
\begin{pmlcode}
  infix (&&) = land⟨⟩ priority 6 right associative
  infix (||) = lor ⟨⟩ priority 7 right associative
\end{pmlcode}

To do so we give the infix symbol between parenthesis (mostly all special
characteres are allowed except delimiters). We give the name of the associated macro (we
could also give an infix notation for a value if we remove \dupml{⟨⟩}).
The priority is a floating point number (the lower the number the
higher the priority) and finally the associativity of the symbol
(\dupml{left}, \dupml{right} or \dupml{none}).

We can now use our macros and their infix notation to define some functions:
\begin{pmlcode}
  val and : bool ⇒ bool ⇒ bool = fun b1 b2 { b1 && b2 }
  val or  : bool ⇒ bool ⇒ bool = fun b1 b2 { b1 || b2 }
  val xor : bool ⇒ bool ⇒ bool =
    fun b1 b2 { (b1 && not b2) || (b2 && not b1) }
\end{pmlcode}

We can prove a few properties:
\begin{pmlcode}
  val not_idempotent : ∀b∈bool, not (not b) ≡ b =
    take b;
    if b { qed } else { qed }

  val demorgan_and : ∀b1 b2∈bool, not (b1 && b2) ≡ not b1 || not b2 =
    take b1 b2;
    set auto 1 0;
    qed

  val demorgan_or : ∀b1 b2∈bool, not (b1 || b2) ≡ not b1 && not b2 =
    take b1 b2;
    set auto 1 0;
    qed
\end{pmlcode}

Nothing is new in these proofs as we are still manipulating finite data
types.

\begin{exercise}\label{exo-bool-1}
  Define implication with the infix notation \dupml{=>} of lower priority than
  \dupml{&&} and \dupml{||} and prove \dupml{b1 && b2 => b3 ≡ b1 => b2 => b3}.
\end{exercise}

\begin{exercise}\label{exo-bool-2}
  Prove that \dupml{xor} and \dupml{&&} satisfy the axiom of a commutative
  semi ring (the are both associative and commutative, \dupml{xor} distributes
  on \dupml{and}, \dupml{false} and \dupml{true} are neutral for \dupml{xor}
  and \dupml{and} respectively and an element is its own opposite for \dupml{xor}).
\end{exercise}

\subsection{Unary natural numbers}

A unary natural number is either zero or the successor of a natural
numbers. This is expressed by the following recursive type:

\begin{pmlcode}
  type rec nat = [ Zero; S of nat ]
\end{pmlcode}

The \dupml{rec} keyword allows to use \dupml{nat} in its own definition.
This definition should be read as ``an element of \dupml{nat} is either the
constant \dupml{Zero} or the \emph{constructor} \dupml{S} applied to an
element of type \dupml{nat}''. The application of a constructor is written
with
square bracket, hence this means that all elements of type \dupml{nat} are
\dupml{Zero}, \dupml{S[Zero]}, \dupml{S[S[Zero]]}, ⋯

Using this we define a few functions on natural numbers:

\begin{pmlcode}
  val zero : nat = Zero
  val succ : nat ⇒ nat = fun n { S[n] }
  val rec dble : nat ⇒ nat = fun n {
    case n {
      Zero → Zero
      S[p] → S[S[dble p]]
    }
  }
\end{pmlcode}

The last function is recursive (indicated by the \dupml{rec} keyword).
Its case analysis is also more complex, in the second case, when
\dupml{n} is a successor, we give a name to the predecessor of \dupml{n}.
This case analysis can be read as either \dupml{n} is equal to \dupml{Zero}
or it is equal to \dupml{S[p]} for some natural number \dupml{p}. This is the
natural case analysis resulting from the definition of the type \dupml{nat}.

Then, in the second case we say that the double of \dupml{n ≡ S[p]} is
\dupml{S[S[dble p]]} and it is here that the function \dupml{dble} calls
itself recursively.

It is important to remark that PML, contrary to most computer languages,
checks the termination of the function \dupml{dble}. For instance the
following is rejected with the error message \dupml{Cannot prove termination}.

\begin{badpmlcode}
  val rec dble : nat ⇒ nat = fun n {
    case n {
      Zero → Zero
      S[p] → S[S[dble n]]
    }
  }
\end{badpmlcode}

We defined the three functions above for a precise reason. PML allows to write
integer constants like \dupml{0}, \dupml{2}, \dupml{-2} or \dupml{42} and they are
replaced by terms using \dupml{zero}, \dupml{succ}, \dupml{dble} and \dupml{opp}.
For instance \dupml{42} is replaced by \dupml{dble (succ (dble (dble (succ (dble
  (dble (succ zero)))))))}.
This allows to use integer constants for any representation of numbers once the above
functions are provided.

We can define more interesting function and gives them an infix notation:

\begin{pmlcode}
  // Addition function.
  infix (+) = add priority 3 left associative

  val rec (+) : nat ⇒ nat ⇒ nat = fun n m {
    case n {
      0    → m
      S[k] → succ (k + m)
    }
  }

  // Multiplication function.
  infix (*) = mul priority 2 left associative

  val rec (*) : nat ⇒ nat ⇒ nat = fun n m {
    case n {
      0    → 0
      S[k] → m + k * m
    }
  }
\end{pmlcode}

We introduce the infix symbol before the definition to use it inside the
definition. We also remark that PML allows to use \dupml{0} for \dupml{Zero}
in case analysis. These are again recursive programs based on the
following equations:

\begin{eqnarray*}
  0 + m &= m \\
  {\rm succ}(n) + m &= {\rm succ}(n + m) \\
  0 × m &= 0 \\
  {\rm succ}(n) × m &= m + n × m \\
\end{eqnarray*}

Many other definitions are possible using other equations as long as they
lead to terminating functions. For instance an alternative definition of
addition could be:

\begin{pmlcode}
  val rec fast_add : nat ⇒ nat ⇒ nat = fun n m {
    case n {
      0    → m
      S[k] → succ (fast_add m k)
    }
  }
\end{pmlcode}

This definition is faster because the complexity of the first definition is
$O(n)$ while the latter is $O(\min(n,m))$. Let us prove that the two
definitions above are equivalent. Here is the beginning of the proof:

\begin{pmlcode}
  val rec add_eq_fast_add : ∀n m∈nat, n + m ≡ fast_add n m =
    take n m;
    case n {
      0    → qed
      S[k] → showing S[k + m] ≡ S[fast_add m k];
             showing k + m ≡ fast_add m k;
             {- unfinished -}
    }
\end{pmlcode}

The zero case is immediate because both \dupml{0 + m} and \dupml{fast_add 0
  m} evaluate to m. For the successor case, we use the \dupml{showing}
keyword to write the current goal, transformed as far as possible using
evaluation. The first \dupml{showing} correspond to evaluation,
The second corresponds to a simplification of the successor on both side.

Using \dupml{showing} corresponds to what is call backward reasonning, we
starts from the goal and make progress toward something which is true.
Forward reasonning is also possible as we will see later.

As for programs, proofs can be recursive, but here using
what we are proving on \dupml{k} and \dupml{m} would lead to
\dupml{k + m ≡ fast_add k m} which is not what we need. A solution is to
prove commutativity of addition which is anyway very usefull. Notice the
notion of \emph{goal} in PML written \dupml{{- ⋯ -}} which allows to
type-check unfinished programs or proofs.

For commutativity we first need two lemmas:
\begin{pmlcode}
  val rec add_n_zero : ∀n∈nat, n + 0 ≡ n =
    take n;
    case n {
      0    → qed
      S[k] → showing S[k] + 0 ≡ S[k];
              showing k + 0 ≡ k;
              use add_n_zero k
    }

  val rec add_n_sm : ∀n m∈nat, n + S[m] ≡ S[n + m] =
    take n m;
    case n {
      0    → qed
      S[k] → showing S[k] + S[m] ≡ S[S[k] + m];
              showing k + S[m] ≡ S[k + m];
              use add_n_sm k m
    }
\end{pmlcode}

In this two lemmas we immediately see that the current goal corresponds to an
induction hypothesis that we can use to finish the proof. It is important to
know that the \dupml{take}, \dupml{showing} and \dupml{use} keywords are
simple syntactic sugar that one can use to make proof readable and also to
gather some knowledge when we are struggling with a difficult proof.  For
instance, if a \dupml{showing} fails, either the current goal is not implied
by what we wrote of we must prove some lemmas to reach the wanted goal.

In fact, much shorter proofs are possible:
\begin{pmlcode}
  val rec add_n_zero : ∀n∈nat, n + 0 ≡ n = fun n {
    case n {
      0    → qed
      S[k] → add_n_zero k
    }
  }

  val rec add_n_sm : ∀n m∈nat, n + S[m] ≡ S[n + m] = fun n m {
    case n {
      0    → qed
      S[k] → add_n_sm k m
    }
  }
\end{pmlcode}

Using these lemmas we can finish the proof of commutativity and
our result on \dupml{fast_add}.

\begin{pmlcode}
  val rec add_commutative : ∀n m∈nat, n + m ≡ m + n =
    take n m;
    case n {
      0    → showing 0 + m ≡ m + 0;
              use add_n_zero m
      S[k] → showing S[k] + m ≡ m + S[k];
              showing S[k + m] ≡ S[m + k] by add_n_sm m k;
              showing k + m ≡ m + k;
              use add_commutative k m
    }

  val rec add_eq_fast_add : ∀n m∈nat, n + m ≡ fast_add n m =
    take n m;
    case n {
      0    → qed
      S[k] → showing S[k + m] ≡ S[fast_add m k];
              showing k + m ≡ fast_add m k;
              showing m + k ≡ fast_add m k by add_commutative m k;
              use add_eq_fast_add m k
    }
\end{pmlcode}

You should notice the use of \dupml{by} together with \dupml{showing} to
justify a reasoning with a proof. Again much shorter (but less readable
proofs) are possible.

\begin{pmlcode}
  val rec add_commutative : ∀n m∈nat, n + m ≡ m + n = fun n m {
    case n {
      0    → add_n_zero m
      S[k] → add_n_sm m k; add_commutative k m
    }
  }

  val rec add_eq_fast_add : ∀n m∈nat, n + m ≡ fast_add n m = fun n m {
    case n {
      0    → qed
      S[k] → add_commutative m k; add_eq_fast_add m k
    }
  }
\end{pmlcode}

\begin{exercise}\label{exo-nat-1}
  Prove the other semi ring axioms for addition and multiplication.
\end{exercise}

\begin{exercise}\label{exo-nat-2}
  Define the power function ($n^m$) and prove that $n^{m+p} = n^m × n^p$ and
  $n^{m × p} = (n^m)^p$.
\end{exercise}

\subsection{Lists}

Here is the definition of the type for lists:
\begin{pmlcode}
  type rec list⟨a⟩ = [Nil ; Cons of {hd : a ; tl : list⟨a⟩}]
\end{pmlcode}

Here we see two novelties. First, \dupml{list} is a parametric type
depending on another type. This means that \dupml{list} is
an expression of sort \dupml{ο → ο}.

Second, we are using records. A record is some kind of association list
which associates values to some labels. The labels are names.

In PML constructor of a sum type
are always applied to exactly one argument. Previously,
\dupml{Monday} and \dupml{Zero} where only shortcut for
\dupml{Monday[{}]} and \dupml{Zero[{}]} that is constructors applied to the
record with no field.

In the type of list, The constructor \dupml{Cons} must be applied to a record
with exactly two labels \dupml{hd} (the head of the list) and \dupml{tl} (the
tail of the list).
Therefore the above definition should be read as an element of type
\dupml{list⟨a⟩} is either \dupml{Nil} or \dupml{Cons[{ hd = h; tl = l}]}
where \dupml{h} is of type \dupml{a} and \dupml{l} is of type
\dupml{list⟨a⟩}.

Let us define a few usual functions on lists:

\begin{pmlcode}
  val rec length : ∀a, list⟨a⟩ ⇒ nat = fun l {
    case l {
      []       → zero
      hd :: tl → succ (length tl)
    }
  }

  val rec map : ∀a b, (a ⇒ b) ⇒ list⟨a⟩ ⇒ list⟨b⟩ = fun fn l {
    case l {
      []       → []
      hd :: tl → fn hd :: map fn tl
    }
  }

  infix (@) = app priority 3 left associative

  val rec (@) : ∀b, list⟨b⟩ ⇒ list⟨b⟩ ⇒ list⟨b⟩ = fun l1 l2 {
    case l1 {
      []       → l2
      hd :: tl → hd :: (tl @ l2)
    }
  }
\end{pmlcode}

First, as lists are very common, two syntactic sugars are provided:
\dupml{[]} for \dupml{Nil} and \dupml{h :: t} for
\dupml{Cons[{hd = h; tl = t}]}. They can be used both in terms and pattern.
  The symbol  \dupml{(::)} is right associative with a priority of 5.

The \dupml{length} and \dupml{map} function should not be very surprising.
One should note the \dupml{∀} in their type as they are \emph{polymorphic}:
they work for lists of elements of any type. For the append function, as we
previously did, we declare the infix symbol we want to use prior to the
definition.

Here are two classical functions on lists:
\begin{pmlcode}
  val rec rev_app : ∀a, list⟨a⟩ ⇒ list⟨a⟩ ⇒ list⟨a⟩ =
    fun l1 l2 {
      case l1 {
        [] → l2
        hd::tl → rev_app tl (hd::l2)
      }
    }

  val rec rev : ∀a, list⟨a⟩ ⇒ list⟨a⟩ =
    fun l { rev_app l [] }

  val rec fold_left : ∀a b, (a ⇒ b ⇒ a) ⇒ a ⇒ list⟨b⟩ ⇒ a =
    fun f a l {
      case l {
        []     → a
        hd::tl → fold_left f (f a hd) tl
      }
    }

  val rec fold_right : ∀a b, (b ⇒ a ⇒ a) ⇒ list⟨b⟩ ⇒ a ⇒ a =
    fun f l a {
      case l {
        []     → a
        hd::tl → f hd (fold_right f tl a)
      }
    }
\end{pmlcode}

The function \dupml{rev_app} is similar to \dupml{(@)}
except it reverse its first argument while concatenating it
on the second. However, it is more efficient because
\dupml{(@)} must remember in the stack the job to do after
the recursive call while for \dupml{rev_app}, the result of the recursive
call is the final result. This means that the second function is not using
a lot of stack space. We say that \dupml{rev_app} is \emph{recursive terminal}.

Then, from \dupml{rev_app} we can define \dupml{rev} to reverse a list.

the two last functions are very classical and defined by the following
equations:
\begin{eqnarray*}
  \dupml{fold_left f a [b1; b2; ⋯ ; bn]} &= \dupml{f (⋯ (f (f a b1) b2) ⋯)
    bn}\\
  \dupml{fold_right f [b1; b2; ⋯ ; bn] a} &= \dupml{f b1 (f b2 (⋯ (f bn a) ⋯))}
\end{eqnarray*}

Notice that the order of the variables \dupml{a}, \dupml{b1}, ⋯, \dupml{bn}
is the same on both side of each equation. The order of the parameters where
chosen to ensure this. Again, \dupml{fold_left} is recursive terminal.
We can now prove a property of these two functions:

\begin{pmlcode}
  val swap : ∀a b c, (a ⇒ b ⇒ c) ⇒ (b ⇒ a ⇒ c) =
    fun f { fun b a { f a b } }

  val rec fold_rev_app : ∀a b, ∀f∈(b ⇒ a ⇒ a), ∀x∈a, ∀l1 l2∈list⟨b⟩,
      fold_left (swap f) x (rev_app l1 l2)
      ≡ fold_left (swap f) (fold_right f l1 x) l2 =
    take f x l1 l2;
    case l1 {
      []     → show fold_left (swap f) x (rev_app l1 l2)
               ≡ fold_left (swap f) x l2
               ≡ fold_left (swap f) (fold_right f l1 x) l2
      hd::tl → show fold_left (swap f) x (rev_app l1 l2)
               ≡ fold_left (swap f) x (rev_app tl (hd::l2))
               ≡ fold_left (swap f) (fold_right f tl x) (hd::l2)
                 by fold_rev_app f x tl (hd::l2)
               ≡ fold_left (swap f) (f hd (fold_right f tl x)) l2
               ≡ fold_left (swap f) (fold_right f l1 x) l2
    }

  val rec fold_rev :  ∀a b, ∀f∈(b ⇒ a ⇒ a), ∀x∈a, ∀l∈list⟨b⟩,
      fold_right f l x ≡ fold_left (swap f) x (rev l) =
    take f x l;
    use fold_rev_app f x l []
\end{pmlcode}

This property is usefull in practice because it might be easier to
prove the correctness of some code with \dupml{fold_right} while
one might want to use \dupml{fold_left} for efficiency. This result  allows
to do both!

\begin{exercise}\label{exo-list-1}
  Prove that reversing twice a list gives the original list. You will need a
  lemma about \dupml{rev_app} which is not surprising ⋯ but also a lemma
  about \dupml{(@)}.
\end{exercise}

\begin{exercise}\label{exo-list-2}
  Prove some result about the composition of \dupml{map} with itself, \dupml{fold_right}
  and \dupml{fold_left}. This kind of lemmas is useful to avoid building
  intermediate lists.
\end{exercise}

\section{Totality issues}\label{sect-totality}

PML, as already mentionned, uses a call-by-value evaluation strategy and
supports some side effect like LISP call-cc (see \ref{sect-classical}) or non
termination.  This leads to difficulties... For instance, by definition of
addition, we know that \dupml{S[x] + g y ≡ S[x + g y]}, but this can not be
proved if \dupml{g y} does not evaluate to a value. If one know that \dupml{g
  y} evaluates to a value, adding a line \dupml{let _ = g y;} will solve the
problem.

Moreover, PML will add such a let automatically when a computation is blocked
by an application which is not know yet to be total. PML will do this at most
3 times because the default level of automation is \dupml{set auto 0 3}. This
means no case analysis added and at most three \dupml{let} definition.

Here is an exemple that illustrates this. The following proof does not
type-check.

\begin{badpmlcode}
   val rec map_app : ∀a b, ∀f∈(a ⇒ b), ∀l1 l2∈list⟨a⟩,
                           map f l1 @ map f l2 ≡ map f (l1 @ l2) =
     take f l1 l2;
     case l1 {
       [] → qed
       h::l → use map_app f l l2
     }
\end{badpmlcode}

Let us write a more detailed proof:
\begin{pmlcode}
   val rec map_app : ∀a b, ∀f∈(a ⇒ b), ∀l1 l2∈list⟨a⟩,
                           map f l1 @ map f l2 ≡ map f (l1 @ l2) =
     take f l1 l2;
     case l1 {
       [] → qed
       h::l → show map f l1 @ map f l2
                 ≡ (f h :: map f l) @ map f l2
                 ≡ f h :: (map f l @ map f l2)
                 ≡ f h :: (map f (l @ l2)) by map_app f l l2
                 ≡ map f (h :: (l @ l2))
                 ≡ map f (l1 @ l2)
     }
\end{pmlcode}

This works because there are more steps and each step needs less than three
\dupml{let} added.

Let us write a proof with all the needed \dupml{let} being explicit (these
are terms that appears in the previous proof and that would block some
evaluation if they where not values):

\begin{pmlcode}
   val rec map_app : ∀a b, ∀f∈(a ⇒ b), ∀l1 l2∈list⟨a⟩,
                           map f l1 @ map f l2 ≡ map f (l1 @ l2) =
     take f l1 l2;
     case l1 {
       [] → qed
       h::l → set auto 0 0; // make sure no let added
              let _ = map f l;
              let _ = map f l2;
              let _ = l @ l2;
              let _ = f h;
              use map_app f l l2
     }
\end{pmlcode}

And a much simpler proof, with the default auto level allowing
to insert some let:
\begin{pmlcode}
   val rec map_app : ∀a b, ∀f∈(a ⇒ b), ∀l1 l2∈list⟨a⟩,
                           map f l1 @ map f l2 ≡ map f (l1 @ l2) =
     take f l1 l2;
     case l1 {
       [] → qed
       h::l → use map_app f l l2
     }
\end{pmlcode}

A few explanation on why this is needed beside the fact that
by choice PML does not have only total functions (i.e. function yielding
values). In the above example, we need the totality of for instance
\dupml{map f l}. By typing, as we use only the arrow denoting total function,
PML knows this yield a value. But in two of the four proofs above, this
expression does not even appears. In the detailed proof, using the
\dupml{show} keyword, the expression appears, but equivalence in PML is
untyped! The use of an untyped equivalnce may seem strange, but is essential to allow proving and using
correct programs that are untyped, provided one can prove their correction.
Thus \dupml{let} (or something equivalent), are necessary to force PML
to typecheck these expressions. As this is very annoying, PML
 will add the needed \dupml{let} automatically.

%<!-- Local IspellDict: british -->
%<!-- Local IspellPersDict: ~/.ispell-british -->
