
\chapter{Solutions of the exercises}

\begin{description}
\item[\ref{exo-day-1}]

  \begin{pmlcode}
    include book.part1_doc.basics

    val rec iter : nat ⇒ ∀a, (a ⇒ a) ⇒ a ⇒ a = fun n f a {
      case n {
        0 → a
        S[n] → iter n f (f a)
      }
    }

    val next_day_seven : ∀d∈day, iter 7 next_day d ≡ d =
      take d;
      case d {
        Monday    → qed
        Tuesday   → qed
        Wednesday → qed
        Thursday  → qed
        Friday    → qed
        Saturday  → qed
        Sunday    → qed
      }
  \end{pmlcode}

\item[\ref{exo-bool-1}]

  \begin{pmlcode}
    infix (=>) = imply⟨⟩ priority 8 right associative

    def (=>)⟨b1:τ,b2:τ⟩ = if b1 { b2 } else { true }

    val tauto1 : ∀b1 b2 b3∈bool, (b1 && b2) => b3 ≡ b1 => (b2 => b3) =
      take b1 b2 b3;
      if b1 { if b2 { qed } else { qed }} else { qed }
  \end{pmlcode}

\item[\ref{exo-bool-2}]

  \begin{pmlcode}
    infix (^^) = xor priority 7 right associative

    val xor : bool ⇒ bool ⇒ bool = fun b1 b2 {
      if b1 { not b2 } else { b2 }
    }

    set auto 3 3

    val xor_com : ∀b1 b2∈bool, b1 ^^ b2 ≡ b2 ^^ b1 =
      take b1 b2; qed

    val xor_ass : ∀b1 b2 b3∈bool, b1 ^^ (b2 ^^ b3) ≡ (b1 ^^ b2) ^^ b3 =
      take b1 b2 b3; qed

    val xor_neutral : ∀b1∈bool, b1 ^^ false ≡ b1 =
      take b1; qed

    val xor_opp : ∀b1∈bool, b1 ^^ b1 ≡ false =
      take b1; qed

    val and_com : ∀b1 b2∈bool, b1 && b2 ≡ b2 && b1 =
      take b1 b2; qed

    val and_ass : ∀b1 b2 b3∈bool, b1 && (b2 && b3) ≡ (b1 && b2) && b3 =
      take b1 b2 b3; qed

    val and_abs :  ∀b1∈bool, b1 && false ≡ false =
      take b1; qed

    val and_neutral : ∀b1∈bool, b1 && true ≡ b1 =
      take b1; qed

    val xor_dist_and :
        ∀b1 b2 b3∈bool, b1 && (b2 ^^ b3) ≡ (b1 && b2) ^^ (b1 && b3) =
      take b1 b2 b3; qed
  \end{pmlcode}

\item[\ref{exo-nat-1}] See {\tt lib/nat\_proofs.pml}

\item[\ref{exo-nat-2}]

  \begin{pmlcode}
    include lib.nat
    include lib.nat_proofs

    val rec pow : nat ⇒ nat ⇒ nat = fun n e {
      case e {
        0    → 1
        S[e] → n * pow n e
      }
    }

    val rec pow_add
        : ∀n e1 e2∈nat, pow n (e1 + e2) ≡ pow n e1 * pow n e2 =
      take n e1 e2;
      case e1 {
        0    → show pow n e1 * pow n e2 ≡ 1 * pow n e2
                 ≡ pow n e2 by mul_one_n (pow n e2)
        S[e] → show pow n (e1 + e2) ≡ n * pow n (e + e2)
                 ≡ n * (pow n e * pow n e2) by pow_add n e e2
                 ≡ (n * pow n e) * pow n e2
                   by mul_assoc n (pow n e) (pow n e2)
                 ≡ pow n e1 * pow n e2
      }

    val rec pow_one_n : ∀n∈nat, pow 1 n ≡ 1 =
      take n;
      case n {
        0    → qed
        S[m] → show 1 * pow 1 m ≡ pow 1 m by mul_one_n (pow 1 m)
                                ≡ 1 by pow_one_n m
      }

    val rec pow_mul_rev
        : ∀n e1 e2∈nat, pow n (e1 * e2) ≡ pow (pow n e2) e1 =
      take n e1 e2;
      case e1 {
        0    → qed
        S[e] → show pow n (e2 + e * e2) ≡ pow n e2 * pow n (e * e2)
                 by pow_add n e2 (e * e2)
               ≡ pow n e2 * pow (pow n e2) e by pow_mul_rev n e e2
               ≡ pow (pow n e2) e1
        }

    val rec pow_mul
        : ∀n e1 e2∈nat, pow n (e1 * e2) ≡ pow (pow n e1) e2 =
      take n e1 e2;
      use mul_comm e1 e2;
      use pow_mul_rev n e2 e1;
      qed
  \end{pmlcode}

\item[\ref{exo-list-1}]
  \begin{pmlcode}
    val rec rev_app_rev_app : ∀a, ∀l1 l2 l3∈list⟨a⟩,
        rev_app (rev_app l1 l2) l3 ≡ rev_app l2 (l1 @ l3) =
      take l1 l2 l3;
      case l1 {
        []   → qed
        h::l → show rev_app (rev_app l1 l2) l3
               ≡ rev_app (rev_app l (h::l2)) l3
               ≡ rev_app (h::l2) (l @ l3)
                 by rev_app_rev_app l (h::l2) l3
               ≡ rev_app l2 (l1 @ l3)
      }

    val rec app_l_nil : ∀a, ∀l∈list⟨a⟩, l @ [] ≡ l =
      take l;
      case l {
        []   → qed
        h::l → app_l_nil l
      }

    val rev_rev : ∀a, ∀l∈list⟨a⟩, rev (rev l) ≡ l =
      take l;
      deduce rev (rev l) ≡ l @ [] by rev_app_rev_app l [] [];
      use app_l_nil l
   \end{pmlcode}

\item[\ref{exo-list-2}]
  \begin{pmlcode}
    infix (°) = compose priority 5 right associative
    val (°) : ∀a b c, (b ⇒ c) ⇒ (a ⇒ b) ⇒ (a ⇒ c) =
      fun f g { fun x { f (g x) } }

    val rec map_map : ∀a b c, ∀f∈(b ⇒ c), ∀g∈(a ⇒ b), ∀l∈list⟨a⟩,
                        map f (map g l) ≡ map (f ° g) l =
      take f g l;
      case l {
        []   → qed
        h::l' → show map f (map g l)
                  ≡ f (g h) :: map f (map g l')
                  ≡ f (g h) :: map (f ° g) l' by map_map f g l'
                  ≡ map (f ° g) l
      }

    val rec fold_right_map :
      ∀a b c, ∀f ∈(b ⇒ c ⇒ c), ∀g∈(a ⇒ b), ∀l∈list⟨a⟩, ∀x∈c,
       fold_right f (map g l) x ≡ fold_right (fun x y {f (g x) y}) l x =
      take f g l x;
      case l {
        []    → qed
        h::l' → let k = fun x y {f (g x) y};
                show fold_right f (map g l) x
                  ≡ f (g h) (fold_right f (map g l') x)
                  ≡ k h (fold_right k l' x)
                    by fold_right_map f g l' x
                  ≡ fold_right k l x
      }

    val rec fold_left_map :
      ∀a b c, ∀f ∈(c ⇒ b ⇒ c), ∀g∈(a ⇒ b), ∀l∈list⟨a⟩, ∀x∈c,
       fold_left f x (map g l) ≡ fold_left (fun x y {f x (g y)}) x l =
      take f g l x;
      case l {
        []    → qed
        h::l' → let k = fun x y {f x (g y)};
                show fold_left f x (map g l)
                  ≡ fold_left f (f x (g h)) (map g l')
                  ≡ fold_left k (k x h) l'
                    by fold_left_map f g l' (k x h)
                  ≡ fold_left k x l
      }
  \end{pmlcode}

  Remark: these proof could be summarized as ``by induction hypothesis'', which
  could be translated in PML by:

  \begin{pmlcode}
    val rec map_map : ∀a b c, ∀f∈(b ⇒ c), ∀g∈(a ⇒ b), ∀l∈list⟨a⟩,
                        map f (map g l) ≡ map (f ° g) l =
      take f g l;
      case l {
        []    → qed
        h::l' → map_map f g l'
      }

    val rec fold_right_map :
      ∀a b c, ∀f ∈(b ⇒ c ⇒ c), ∀g∈(a ⇒ b), ∀l∈list⟨a⟩, ∀x∈c,
       fold_right f (map g l) x ≡ fold_right (fun x y {f (g x) y}) l x =
      take f g l x;
      case l {
        []    → qed
        h::l' → fold_right_map f g l' x
      }

    val rec fold_left_map :
      ∀a b c, ∀f ∈(c ⇒ b ⇒ c), ∀g∈(a ⇒ b), ∀l∈list⟨a⟩, ∀x∈c,
       fold_left f x (map g l) ≡ fold_left (fun x y {f x (g y)}) x l =
      take f g l x;
      case l {
        []    → qed
        h::l' → fold_left_map f g l' (f x (g h))
      }
  \end{pmlcode}

\item[\ref{exo-alist-1}]

  Remark: we need the \dupml{map_app} lemma from \ref{sect-totality}.

  \begin{pmlcode}
    include book.part1_doc.subtype

    val rec alist_map : ∀a b, (a ⇒ b) ⇒ alist⟨a⟩ ⇒ alist⟨b⟩ =
      fun f l1 {
        case l1 {
          []   → []
          h::l → f h :: alist_map f l
          Append[{l;r}] → Append[{l=alist_map f l; r = alist_map f r}]
        }
      }

    val rec alist_map_map : ∀a b, ∀f∈(a⇒b), ∀l∈alist⟨a⟩,
      alist_to_list (alist_map f l) ≡ map f (alist_to_list l) =
      take f l1;
      case l1 {
        []   → qed
        h::l → alist_map_map f l
        Append[{l;r}] →
          alist_map_map f l; alist_map_map f r;
          showing (map f (alist_to_list l) @ map f (alist_to_list r))
            ≡ map f (alist_to_list l @ alist_to_list r);
          use map_app f (alist_to_list l) (alist_to_list r)
      }
  \end{pmlcode}

  \item[\ref{exo-int-1}] See \dupml{lib/int.pml} and
    \dupml{lib/int_proofs.pml}.

  \item[\ref{exo-int-2}]

    Two solutions, using comprehension:

    \begin{pmlcode}
      val rec opp : ∀n∈int,
        { r ∈ int | r ≡ case n { 0 → r | S[_] → opp_pos n | P[_] → opp_neg n
        } } =
        fun n {
            case n {
            0    → 0
            S[p] → let _ = opp p; // TODO: auto should find this
                    P[check opp_pos p for opp p]
            P[s] → let _ = opp s; // TODO: auto should find this
                    S[check opp_neg s for opp s]
          }
        }
    \end{pmlcode}

    or mutually recursive functions and lemmas (PML needs syntactic sugar):
    \begin{pmlcode}
      val rec r :
        ∃r, r ∈ { opp : int ⇒ int
        ; opp_pos_lem : ∀p∈pos, r.opp p ≡ opp_pos p
        ; opp_neg_lem : ∀n∈neg, r.opp n ≡ opp_neg n } =
        { opp = fun n {
            case n {
              0    → 0
              S[p] → P[check {opp_pos p} for r.opp p by r.opp_pos_lem p]
              P[s] → S[check opp_neg s for r.opp s by r.opp_neg_lem s]
            }
          }
        ; opp_pos_lem = (
          take p;
          case p {
            0    → qed
            S[k] → r.opp_pos_lem k
          })
        ; opp_neg_lem = (
          take n;
          case n {
            0    → qed
            P[k] → r.opp_neg_lem k
          })
        }

      val opp : int ⇒ int = r.opp
    \end{pmlcode}
\end{description}

%<!-- Local IspellDict: british -->
%<!-- Local IspellPersDict: ~/.ispell-british -->
