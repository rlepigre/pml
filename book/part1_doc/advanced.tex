\chapter{Advanced feature}

\section{Dealing with termination}\label{sect-nontermination}

Here is a classical example used to break termination
prover: the Mc Carthy 91 function. Here is the definition
of the function, using the arrow denoting possible non termination
as PML can not prove the termination of this function.

\begin{pmlcode}
  include lib.nat
  include lib.nat_proofs

  val rec mccarthy91 : nat ↛ nat = fun n {
    if n > 100 {
      n - 10
    } else {
      mccarthy91 (mccarthy91 (n + 11))
    }
  }
\end{pmlcode}

In fact this function is computing the same value (in a very complex way)
as the following.

\begin{pmlcode}
  include lib.nat

  val mccarthy91_easy : nat ⇒ nat = fun n {
    if n > 100 {
      n - 10
    } else {
      91
    }
  }
\end{pmlcode}

Now it is not very hard to prove the equivalence of both functions,
using 101 cases automatically generated by PML and computing
\dupml{mccarthy91 n} for all integers between 0 and 100!

\begin{pmlcode}
  val hard_lemma : ∀n∈nat, n ≤ 100 ⇒ mccarthy91 n ≡ 91 =
    take n; suppose n ≤ 100;
    {-set auto 101 1; qed -} // this takes ~3mn so we commented it

  val hard_is_easy : ∀n∈nat, mccarthy91_easy n ≡ mccarthy91 n =
    take n;
    if n > 100 {
      show mccarthy91_easy n ≡ n - 10 ≡ mccarthy91 n
    } else {
      deduce n ≤ 100 using { geq_gt 100 n; leq_geq n 100};
      show mccarthy91_easy n ≡ 91
        ≡ mccarthy91 n using hard_lemma n {}
    }
\end{pmlcode}

Notice the use of some lemmas from \dupml{lib.nat_proofs} to
prove that \dupml{n ≤ 100} is the second case.

Now, we can define a function that will be typed as \dupml{mccarthy_easy}
but evaluated as \dupml{mccarthy91}. This is useless here, but would be
useful if \dupml{mccarthy91} were an optimised version of
\dupml{mccarthy_easy}.

\begin{pmlcode}
  val mccarthy91 : nat ⇒ nat =
  fun n {
      check { mccarthy91_easy n }
      for { mccarthy91 n }
      because { hard_is_easy n }
  }
\end{pmlcode}

The \dupml{check ⋯ for ⋯} construct require a proof that the two
expressions are equivalent to accept to typecheck one expression and replace
it by the second expression. This new version of \dupml{mccathy91} is really
equivalent to the original one but with a stronger type (using the total arrow).

\section{Inductive and co-inductive data types}

\section{Classical proofs}\label{sect-classical}

%<!-- Local IspellDict: british -->
%<!-- Local IspellPersDict: ~/.ispell-british -->
